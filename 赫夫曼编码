#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>

#define MAX_INT 100

typedef struct {
    int weight;
    int parent;
    int left_child;
    int right_child;
} huffman_node;

void select(huffman_node Bi_tree[], int n, int* p1, int* p2) {
    int i;
    int min1, min2;
    min1 = min2 = -1;

    // 找到两个最小的权值
    for (i = 0; i < n; i++) {
        if (Bi_tree[i].parent == -1) {
            if (min1 == -1 || Bi_tree[i].weight < Bi_tree[min1].weight) {
                min2 = min1;
                min1 = i;
            }
            else if (min2 == -1 || Bi_tree[i].weight < Bi_tree[min2].weight) {
                min2 = i;
            }
        }
    }
    *p1 = min1;
    *p2 = min2;
}

void create_tree(huffman_node Bi_tree[], int n) {
    int i, p1, p2;
    for (i = 0; i < 2 * n - 1; i++) {
        Bi_tree[i].left_child = -1;
        Bi_tree[i].right_child = -1;
        Bi_tree[i].parent = -1;
        Bi_tree[i].weight = 0;
    }

    for (i = 0; i < n; ++i) {
        printf("请输入第 %d 个叶子节点的权重：", i + 1);
        scanf_s("%d", &Bi_tree[i].weight);
    }
    //初始化完成
    for (i = n; i < 2 * n - 1; i++) {
        select(Bi_tree, i, &p1, &p2);
        Bi_tree[p1].parent = i;
        Bi_tree[p2].parent = i;
        Bi_tree[i].weight = Bi_tree[p1].weight + Bi_tree[p2].weight;

        Bi_tree[i].left_child = p1;
        Bi_tree[i].right_child = p2;
    }
}
/*其实所谓的赫夫曼编码就是在赫夫曼树的基础上把那些“01010101”这些数字表示出来，
* 但是表示出来就有一个数组可以储存一整串数字，而且每一串数字都有自己对应的结点
，还有一个数组一个个储存0，1。
  1、需要创建一个二级数组code_table（创建n个指针，用于指向每一个数组用char**）并为分配空间
  2、char* code_table[i] （第i个指针） =  (char*)malloc((n - start) * sizeof(char));分配储存空间存放一整串的编码
  3、定义一个cd指针，并且动态分配一个数组用来接受每一次的0或者1
  4、用递归，从叶子遍历到根结点，存到cd指针对应的数组里
  5、用strcpy_s把cd指针对应数组的值拷贝给二级数组分配好的空间里
  6、再定义函数将其输出
    */
void get_huffman_code(huffman_node Bi_tree[], int n, char** code_table) {
    char* cd;//定义一个指针，用于存储0，1数字的动态内存空间地址
    int i, start, c, f;
    cd = (char*)malloc(n * sizeof(char));//至于为什么要定义n个，虽然n个字节，编码只有n-1位，但是最后一个得有一个\0用于终止，防止越位
    cd[n - 1] = '\0';

    for (i = 0; i < n; i++) {
        start = n - 1;
        c = i;
        f = Bi_tree[i].parent;

        while (f != -1) {
            --start;
            if (Bi_tree[f].left_child == c) {
                cd[start] = '0';
            }
            else {
                cd[start] = '1';
            }
            c = f;
            f = Bi_tree[f].parent;
        }                             
          code_table[i] = (char*)malloc((n - start) * sizeof(char));/*为第i个指针所对应的数组创造, 在get_huffman_code函数中，
                                                                   每个编码的长度是不同的，所以需要为每个编码动态分配空间*/
        strcpy_s(code_table[i], (n - start) * sizeof(char), &cd[start]);/*把编码从cd拷贝到code_table, 用的是C语言自带的拷贝函数,
                                                                 code_table[i]和& cd[start]都是地址，(n - start) * sizeof(char)是长度*/
    }
    free(cd);
}
//输出编码
void print_code_table(char** code_table, int n) {
    printf("Huffman编码：\n");
    printf("字符\t编码\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%s\n", i, code_table[i]);
    }
}

int main() {
    int n;
    printf("请输入叶子节点个数：");
    scanf_s("%d",&n);
    huffman_node Bi_tree[MAX_INT];
    create_tree(Bi_tree, n);

    char** code_table = (char**)malloc(n * sizeof(char*));//用一个二级数组，这个数组分配了n个指针来指向每一个数组
    for (int i = 0; i < n; i++) {
        code_table[i] = (char*)malloc((n - 1) * sizeof(char));/*在主函数中分配的空间只是为了指向每个编码的存储地址，
                                                                      而不是为每个编码真正的分配内存空间。*/
    }
    get_huffman_code(Bi_tree, n, code_table);

    print_code_table(code_table, n);

    for (int i = 0; i < n; i++) {
       free(code_table[i]);//释放掉每一个i指针指向的数组
    }
    free(code_table);//释放二级数组

    return 0;

}
            
